//
//  ASLInterpreterWorker.swift
//  ASLInterpreter
//
//  Created by Daniel Gallego Peralta on 28/3/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ASLInterpreterDelegate: class {
    func aslInterpreter(_ controller: ASLInterpreterWorker, didDetectWord word: String)
}

class ASLInterpreterWorker {
    
    private let queue = DispatchQueue(label: "ASLInterpreterWorker.danigp.es")
    
    private var predictions: [String] = []
    private var lastLetter: String = ""
    private var word: [String] = []
    private var isWritingWord: Bool = false
    let textChecker = UITextChecker()
    weak var delegate: ASLInterpreterDelegate?
    
    func lastPrediction(_ letter: String) {
        if ASLConfiguration.shared.workingMode == ASLConfiguration.WorkingMode.free {
            self.delegate?.aslInterpreter(self, didDetectWord: letter)
            return
        }
        
        switch ASLConfiguration.shared.workingMode {
        case .words:
            detectingWord(letter)
        default:
            detectMinOcurrencesLetter(letter)
        }
    }
    
    func detectMinOcurrencesLetter(_ letter: String) {
        queue.async { [unowned self] in
            self.predictions.append(letter)
            
            if predictions.count >= ASLConfiguration.shared.minLettersToCompare {
                let slide = predictions.suffix(ASLConfiguration.shared.minLettersToCompare)
                let lastPredictions = Array(slide)
                
                let occurences: [Occurrence] = getNumberOfOccurrences(lastLetters: lastPredictions)
                guard let topResult = getTopResult(ocurrences: occurences) else {
                    return
                }
                
                if topResult.times >= ASLConfiguration.shared.minOcurrences && topResult.letter != lastLetter {
                    lastLetter = topResult.letter
                    predictions.removeAll()
                    delegate?.aslInterpreter(self, didDetectWord: topResult.letter)
                }
            }
        }
    }
    
    func detectingWord(_ letter: String) {
        let minLettersToCompare: Int = 6
        let minOcurrences: Int = 6
        let specialLettersOcurrences = minLettersToCompare + 2
        let specialLetters: Set<String> = ["P"]
        
        queue.async { [unowned self] in
            self.isWritingWord = true
            self.predictions.append(letter)
            let isSpecialLetter = specialLetters.contains(letter)
            let numberLettersToCompare =  isSpecialLetter ? specialLettersOcurrences : minLettersToCompare
            let shouldVerify: Bool = predictions.count >= numberLettersToCompare
            
            if shouldVerify {
                let slide = predictions.suffix(numberLettersToCompare)
                let lastOcurrences = Array(slide)
                
                let occurences: [Occurrence] = getNumberOfOccurrences(lastLetters: lastOcurrences)
                guard let topResult = getTopResult(ocurrences: occurences) else {
                    return
                }
                
                let compareTo = isSpecialLetter ? specialLettersOcurrences : minOcurrences
                if topResult.times >= compareTo && topResult.letter != lastLetter {
                    lastLetter = topResult.letter
                    predictions.removeAll()
                    word.append(topResult.letter)
                    
                    let newWord = word.joined()
                    delegate?.aslInterpreter(self, didDetectWord: newWord)
                }
            }
        }
    }
    
    func finishWord() {
        queue.async { [unowned self] in
            if isWritingWord {
                isWritingWord = false
                lastLetter = ""
                print("finishword")
                
                if ASLConfiguration.shared.isTextCheckerEnabled {
                    print("textChecking")
                    var newWord = word.joined()
                    let language = "en"
                    let rangeMisspelled = textChecker.rangeOfMisspelledWord(in: newWord, range: NSRange(0..<newWord.utf16.count), startingAt: 0, wrap: false, language: language)
                    if rangeMisspelled.location != NSNotFound {
                        if let guess = textChecker.guesses(forWordRange: rangeMisspelled, in: newWord, language: language)?.first {
                            newWord = guess
                            print("newWord: guess: \(guess)")
                        }
                    }
                    delegate?.aslInterpreter(self, didDetectWord: newWord)
                }
                
                self.word.removeAll()
            }
        }
    }
    
    //MARK: - Utils
    
    func getNumberOfOccurrences(lastLetters: [String]) -> [Occurrence] {
        var occurences: [Occurrence] = []
        
        lastLetters.forEach { letter in
            let ocurrence = occurences.filter { $0.letter == letter}.first
            if let _ = ocurrence {
                ocurrence?.increment()
            } else {
                occurences.append(Occurrence(letter: letter, times: 1))
            }
        }
        
        return occurences
    }
    
    func getTopResult(ocurrences: [Occurrence]) -> Occurrence? {
        return ocurrences.sorted { return $0.times > $1.times }.first
    }
}
